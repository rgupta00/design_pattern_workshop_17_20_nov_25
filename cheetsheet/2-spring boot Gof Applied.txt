
Bank application applicatation spring boot with GOF patterns
-------------------------------------------------------------
	* Spring vs Spring boot, Spring boot introduction 
	* Understanding DIP DI and IOC, how it works
	* AOP how to handle cross cutting concerns
	* Desigining 3 tier arch, how to achive loose coupling in real application
	* Creating REST api, exception handing
	* Applying logging with aop
	* Applying strategy pattern
	* spring boot data jpa
	* Excpetion handling
	* Actuator

Step 1: understading why we need DI?
------------------------------------
bank application 3 tier
controller layer -------------------- service layer ------------------- dao layer --------------db
																	repository layer
																
Step 2: getting started fund transfer application:
------------------------------------------

Dao layer:
--------------															
public class Account {
    private int id;
    private String name;
    private BigDecimal balance;
}
	
public interface AccountDao {
	public List<Account> getAll();
	public Account getById(int id);
	public void updateAccount(Account account);
	public void addAccount(Account account);
	public void deleteAccount(int id);
}


public class AccountDaoCollectionImpl implements AccountDao{
	private Map<Integer, Account> accounts=new HashMap<>();
	
	public AccountDaoCollectionImpl() {
		accounts.put(1, new Account(1, "raj", 560000.00));
		accounts.put(2, new Account(2, "ekta", 760000.00));
	}
	@Override
	public List<Account> getAll() {
		System.out.println("getAll using hard coded collection...");
		return new ArrayList<Account>(accounts.values());
	}

	@Override
	public Account getById(int id) {
		return accounts.get(id);
	}

	@Override
	public void updateAccount(Account account) {
		accounts.put(account.getId(), account);
	}

}

Service layer:
-----------------
public interface AccountService {
    public List<Account> getAll();
    public Account getById(int id);
	
    public void addAccount(Account account);
    public void deleteAccount(int id);

    public void transfer(int fromAccId, int toAccId, BigDecimal amount);
    public void deposit(int accId, BigDecimal amount);
    public void withdraw(int accId, BigDecimal amount);
}

Step 3: controller layer:
-------------------------



Step 4:Spring boot singleton prototype pattern demostration
------------------------------------------------------

Singleton Pattern â€” One instance shared globally
----------------------------------------------
Use Case: Centralized transaction logger.

public class TransactionLogger {

    private static TransactionLogger instance;

    private TransactionLogger() {}

    public static synchronized TransactionLogger getInstance() {
        if (instance == null) {
            instance = new TransactionLogger();
        }
        return instance;
    }

    public void log(String message) {
        System.out.println("[LOG] " + message);
    }
}

with spring boot :
------------
@Service
public class TransactionLogger {

    public void log(String message) {
        System.out.println("[LOG] " + message);
    }
}

What Happens Internally
-------------------------
	Spring creates exactly one instance of this bean at startup.
	The bean is cached inside the ApplicationContext.
	Whenever itâ€™s @Autowired anywhere, Spring injects the same instance.


Implementing prototype pattern with spring boot:
------------------------------------------------------
@Component
@Scope("prototype")  // each request gives a new instance
public class TransactionIdGenerationService {
    private String transactionId;

    public TransactionIdGenerationService() {
        this.transactionId = "TXN-" + System.currentTimeMillis();
        System.out.println("Creating new TransactionPrototype: " + transactionId);
    }

    public String getTransactionId() {
        return transactionId;
    }
}

and how to use it?
------------------
@Service
public abstract class FundTransferService {

    public void transfer(double amount) {
        TransactionIdGenerationService txn = createTransaction(); // ðŸ’¥ new prototype each time
        System.out.println("Processing " + txn.getId());
    }

    @Lookup
    protected abstract TransactionIdGenerationService createTransaction();
}


Bean					Scope					Purpose
TransactionLogger		@Service (Singleton)	Shared logger instance
TransactionPrototype	@Scope("prototype")		Fresh transaction object per transfer
FundTransferService		@Service (Singleton)	Business logic, injects prototype 
												dynamically via ObjectFactory, Provider, or @Lookup

Builder Pattern Using Lombok (Modern, Simple)



Step 5:Spring boot Exception handing
-------------------------------------

Exception handing:
------------------
@RestControllerAdvice
public class AccountExceptionRestController {

	@Autowired
	private Environment environment;

	// ---------handling 404 error------
	@ExceptionHandler(AccountNotFoundException.class)
	public ResponseEntity<ErrorInfo> handleAccountNotFound(AccountNotFoundException accountNotFoundException) {
		ErrorInfo errorInfo = new ErrorInfo().builder().dateTime(LocalDateTime.now()).toContact("masterbank@bank.com")
				.errorCode(404).errorMessage(environment.getProperty(accountNotFoundException.getMessage())).build();
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorInfo);
	}

	// ---------handling 500 error------
	@ExceptionHandler(Exception.class)
	public ResponseEntity<ErrorInfo> handle500(Exception exception) {
		ErrorInfo errorInfo = new ErrorInfo().builder().dateTime(LocalDateTime.now()).toContact("masterbank@bank.com")
				.errorCode(500).errorMessage(environment.getProperty(exception.getMessage())).build();
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorInfo);
	}

}




Step 6: Spring boot AOP proxy design pattern
----------------------------------------------
	Applying logging advice to fund transfer application:


@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Loggable {

}


import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
@Component
@Aspect
public class MethodLogger {
	private static final Logger logger=LoggerFactory.getLogger(MethodLogger.class); 
	
  @Around("@annotation(Loggable)")
  public Object around(ProceedingJoinPoint point) throws Throwable {
    long start = System.currentTimeMillis();
    Object result = point.proceed();
    logger.info("Method call takes" +(System.currentTimeMillis() - start));
    return result;
  }
}


// logger.info("start "+MethodSignature.class.cast(point.getSignature()).getMethod().getName()+" is called"+" takes+(System.currentTimeMillis() - start));





Facade pattern
------------------------------
	 Simplifies complex workflows
	 Reduces coupling between controller and services
	 Makes testing and maintenance easier
	 Perfect entry point for REST APIs in layered Spring Boot apps

Controller â†’ FundTransferFacade â†’ [AccountService, LedgerService, FraudService, NotificationService]


Subsystems â€” Complex Services
---------------------------------
AccountService.java
-----------------------
public class AccountService {
   public void transfer(int from, int to, double amount){
   
	}
}

LedgerService.java
-----------------------
public class LedgerService {
    public void record(int from, int to, double amount) {
        System.out.println("Ledger updated: Transfer of " + amount + " from " + from + " to " + to);
    }
}

FraudService.java
-----------------------
public class FraudService {
    public boolean validate(int from, int to, double amount) {
        System.out.println("Validating fraud for " + amount + " transfer...");
        return amount < 100000; // simple rule
    }
}

NotificationService.java
-----------------------
public class NotificationService {
    public void send(String message) {
        System.out.println("SMS Notification Sent: " + message);
    }
}

The Facade Class

FundTransferFacade.java
-----------------------
public class FundTransferFacade {
public void transferFunds(String fromAcc, String toAcc, double amount);
}

public class FundTransferFacadeImpl {

    private final AccountService accountService;
    private final LedgerService ledgerService;
    private final FraudService fraudService;
    private final NotificationService notificationService;

    public FundTransferFacade() {
        this.accountService = new AccountService();
        this.ledgerService = new LedgerService();
        this.fraudService = new FraudService();
        this.notificationService = new NotificationService();
    }

    public void transferFunds(String fromAcc, String toAcc, double amount) {
        System.out.println("---- Initiating Fund Transfer ----");

        if (!fraudService.validate(fromAcc, toAcc, amount)) {
            notificationService.send("Transfer blocked due to suspected fraud!");
            System.out.println(" Fraud detected, transfer aborted.");
            return;
        }

        accountService.debit(fromAcc, amount);
        accountService.credit(toAcc, amount);
        ledgerService.record(fromAcc, toAcc, amount);
        notificationService.send("Transfer of â‚¹" + amount + " from " + fromAcc + " to " + toAcc + " successful!");

        System.out.println(" Transfer completed successfully!");
    }
}



Spring filter: 


Spring boot filter and interceptor example:
---------------------------------------------
spring mvc arch

how filter chain and interceptor difference
https://www.baeldung.com/spring-mvc-handlerinterceptor-vs-filter

Example:
public class FirstInterceptor implements HandlerInterceptor {
}
public class SecondInterceptor implements HandlerInterceptor {}

configuration:
-------------
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // Lower order = higher priority
        registry.addInterceptor(new FirstInterceptor())
                .addPathPatterns("/**")
                .order(1); // executes first

        registry.addInterceptor(new SecondInterceptor())
                .addPathPatterns("/**")
                .order(2); // executes second
    }
}

or alternative config: if use @Component annotation with interceptor

@Configuration
public class WebConfig implements WebMvcConfigurer {

    private final FirstInterceptor firstInterceptor;
    private final SecondInterceptor secondInterceptor;

    public WebConfig(FirstInterceptor firstInterceptor, SecondInterceptor secondInterceptor) {
        this.firstInterceptor = firstInterceptor;
        this.secondInterceptor = secondInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(firstInterceptor).order(1);
        registry.addInterceptor(secondInterceptor).order(2);
    }
}

Spring filters:
--------------------
A Filter in Spring Boot (Servlet filter) intercepts HTTP requests before 
they reach the DispatcherServlet (unlike interceptors, which work after it).

Filters are used for:
	Logging or auditing requests
	Authentication/Authorization
	Request/response modification
	Setting security headers, etc

@Component
@Order(1)
public class FirstFilter implements Filter {
@Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest req = (HttpServletRequest) request;
        System.out.println(" FirstFilter - Request URI: " + req.getRequestURI());

        // continue filter chain
        chain.doFilter(request, response);

        System.out.println("FirstFilter - Response returned.");
    }
}

@Component
@Order(2)
public class SecondFilter implements Filter {}

Note: filter automatically configured if you are using @Component and Order annotation

but in case if u are not using it :
-----------------------------------
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<FirstFilter> firstFilter() {
        FilterRegistrationBean<FirstFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new FirstFilter());
        registration.addUrlPatterns("/api/*");   // apply only to /api/
        registration.setOrder(1);
        return registration;
    }

    @Bean
    public FilterRegistrationBean<SecondFilter> secondFilter() {
        FilterRegistrationBean<SecondFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new SecondFilter());
        registration.addUrlPatterns("/*");       // apply to all
        registration.setOrder(2);
        return registration;
    }
}

Spring provides a special abstract class:
-----------------------------------------
public abstract class OncePerRequestFilter implements Filter{}


	It ensures that your filter runs only once per request (even if the request passes through multiple dispatch types,
	 such as FORWARD or INCLUDE).

	Without it, filters might accidentally run multiple times 
	â€” especially in apps using error pages, forwards, or includes.


How to list spring security filter chain?
------------------------------------
@Configuration
public class SecurityFilterLoggerConfig {

    @Bean
    public CommandLineRunner logSecurityFilters(FilterChainProxy filterChainProxy) {
        return args -> {
            System.out.println("Active Spring Security Filter Chains:");
            int index = 1;
            for (SecurityFilterChain chain : filterChainProxy.getFilterChains()) {
                System.out.println("\nFilter Chain " + index++ + ": " + chain);
                chain.getFilters().forEach(f -> System.out.println("   âž¡ " + f.getClass().getName()));
            }
        };
    }
}


spring.security.debug=true
logging.level.org.springframework.security=DEBUG
logging.level.org.springframework.security.web=DEBUG



Spring jdbc: Template design pattern in action
---------------------------------------------
Spring boot jdbcTemplate
-----------------------
without jdbcTemplate
========================
@Repository
public class AccountDaoJdbcImpl implements AccountDao {

    private final DataSource dataSource;

    // âœ… Constructor-based dependency injection
    public AccountDaoJdbcImpl(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public List<Account> getAll() {
        String sql = "SELECT id, name, balance FROM accounts";
        List<Account> accounts = new ArrayList<>();

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                Account account = new Account(
                        rs.getInt("id"),
                        rs.getString("name"),
                        rs.getBigDecimal("balance")
                );
                accounts.add(account);
            }

        } catch (SQLException e) {
            throw new RuntimeException("Error fetching all accounts", e);
        }

        return accounts;
    }

    @Override
    public Account getById(int id) {
        String sql = "SELECT id, name, balance FROM accounts WHERE id = ?";
        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setInt(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return new Account(
                            rs.getInt("id"),
                            rs.getString("name"),
                            rs.getBigDecimal("balance")
                    );
                }
            }

        } catch (SQLException e) {
            throw new RuntimeException("Error fetching account by ID: " + id, e);
        }

        return null;
    }

    @Override
    public void updateAccount(Account account) {
        String sql = "UPDATE accounts SET name = ?, balance = ? WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setString(1, account.getName());
            ps.setBigDecimal(2, account.getBalance());
            ps.setInt(3, account.getId());

            ps.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException("Error updating account ID: " + account.getId(), e);
        }
    }
}


with jdbcTemplate
==================
step 1: define rowmapper:
-----------------------
public class AccountRowMapper implements RowMapper<Account> {

    @Override
    public Account mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Account(
                rs.getInt("id"),
                rs.getString("name"),
                rs.getBigDecimal("balance")
        );
    }
}

step 1: use jdbctemplate:
-----------------------

@Repository
public class AccountDaoJdbcTemplateImpl implements AccountDao {

    private final JdbcTemplate jdbcTemplate;

    // âœ… Constructor-based injection
    public AccountDaoJdbcTemplateImpl(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public List<Account> getAll() {
        String sql = "SELECT id, name, balance FROM accounts";
        return jdbcTemplate.query(sql, new AccountRowMapper());
    }

    @Override
    public Account getById(int id) {
        String sql = "SELECT id, name, balance FROM accounts WHERE id = ?";
        List<Account> list = jdbcTemplate.query(sql, new AccountRowMapper(), id);

        return list.isEmpty() ? null : list.get(0);
    }

    @Override
    public void updateAccount(Account account) {
        String sql = "UPDATE accounts SET name = ?, balance = ? WHERE id = ?";
        jdbcTemplate.update(sql,
                account.getName(),
                account.getBalance(),
                account.getId()
        );
    }
}




Spring boot bankapp: strategy design pattern:
============================================
public enum TransactionType {
    NEFT, RTGS, IMPS
}

@Data
public class TransactionRequest {
    private int fromAccId;
    private int toAccId;
    private BigDecimal amount;
    private TransactionType txType;
}


public interface TransactionStrategy {
    void transfer(Account from, Account to, BigDecimal amount);
}


@Component("NEFT")
public class NEFTStrategy implements TransactionStrategy {
    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        System.out.println("Processing NEFT transfer...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }
}

@Component("RTGS")
public class RTGSStrategy implements TransactionStrategy {
    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        System.out.println("Processing RTGS transfer with high-value check...");
        if (amount.compareTo(new BigDecimal("200000")) < 0) {
            throw new IllegalArgumentException("RTGS minimum amount should be â‚¹2,00,000");
        }
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }
}

@Component("IMPS")
public class IMPSStrategy implements TransactionStrategy {
    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        System.out.println("Processing IMPS instant transfer...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }
}


@Component
public class TransactionStrategyFactory {

    private final Map<String, TransactionStrategy> strategyMap;

    @Autowired
    public TransactionStrategyFactory(Map<String, TransactionStrategy> strategyMap) {
        this.strategyMap = strategyMap;
    }

    public TransactionStrategy getStrategy(TransactionType type) {
        return strategyMap.get(type.name());
    }
}



@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private TransactionStrategyFactory factory;

    public void executeTransfer(int fromAccId, int toAccId, BigDecimal amount, TransactionType type) {
        Account from = dao.getById(fromAccId);
        Account to = dao.getById(toAccId);
        TransactionStrategy strategy = factory.getStrategy(type);
        strategy.transfer(from, to, amount);
        dao.updateAccount(from);
        dao.updateAccount(to);
    }
}


@RestController
@RequestMapping("/api/transactions")
public class TransactionController {

    @Autowired
    private AccountService service;

    @PostMapping("/transfer")
    public String transferFunds(@RequestBody TransactionRequest request) {
        service.executeTransfer(
                request.getFromAccId(),
                request.getToAccId(),
                request.getAmount(),
                request.getTxType()
        );
        return "Transfer of â‚¹" + request.getAmount() +
               " via " + request.getTxType() + " completed successfully.";
    }
}




You already have:
------------------------------
TransactionStrategy â€” defines algorithm family (which strategy to use, e.g., NEFT, RTGS, etc.)
Each concrete strategy (NEFTStrategy, RTGSStrategy) â€” implements transfer(...).

Now, youâ€™ll add a Template pattern to:
-----------------------------------------
Define a fixed skeleton of a transfer process (pre-check â†’ core transfer â†’ audit â†’ notification).
Let each subtype (strategy) override only the variable steps (like how transfer happens or fee calculation).

This gives you two levels of flexibility:
-------------------------------------------
Strategy â†’ chooses which transaction method to execute (runtime decision).
Template â†’ defines how the method itself is structured internally.



public abstract class AbstractTransactionTemplate {
    // Template method: defines the workflow
    public final void executeTransfer(Account from, Account to, BigDecimal amount) {
        validateAccounts(from, to);
        preTransfer(from, to, amount);
        doTransfer(from, to, amount);     // delegated to subclass
        postTransfer(from, to, amount);
        notifyParties(from, to, amount);
        auditTransaction(from, to, amount);
    }

    // Common steps (can be final or overridable)
    protected void validateAccounts(Account from, Account to) {
        if (from == null || to == null) {
            throw new IllegalArgumentException("Invalid accounts provided");
        }
        if (from.getBalance().compareTo(amountLimit()) < 0) {
            throw new IllegalStateException("Insufficient funds in sender account");
        }
    }

    protected void preTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Starting transaction of amount " + amount);
    }

    protected abstract void doTransfer(Account from, Account to, BigDecimal amount);

    protected void postTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Transaction completed successfully");
    }

    protected void notifyParties(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Sending SMS to both parties");
    }

    protected void auditTransaction(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Auditing transaction in log system");
    }

    // hook method â€” subclasses may override
    protected BigDecimal amountLimit() {
        return BigDecimal.ZERO;
    }
}


This class provides theConcrete Transaction Templates
------------------------------------------------------------
Each strategy (e.g., NEFT, RTGS, IMPS) can extend this template and override the variable steps.

package com.busycoder.bank.strategy;

import com.busycoder.bank.model.Account;
import com.busycoder.bank.template.AbstractTransactionTemplate;
import org.springframework.stereotype.Component;
import java.math.BigDecimal;

@Component("NEFT")
public class NEFTTransaction extends AbstractTransactionTemplate implements TransactionStrategy {

    @Override
    protected void doTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[NEFT] Deducting amount slowly via NEFT network...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }

    @Override
    protected BigDecimal amountLimit() {
        return new BigDecimal("10000"); // NEFT has a minimum threshold check (example)
    }

    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        executeTransfer(from, to, amount);
    }
}


Similarly, for RTGS:
-----------------------
@Component("RTGS")
public class RTGSTransaction extends AbstractTransactionTemplate implements TransactionStrategy {

    @Override
    protected void doTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[RTGS] High-value instant transfer...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }

    @Override
    protected void postTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[RTGS] Sending instant confirmation email for RTGS.");
    }

    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        executeTransfer(from, to, amount);
    }
}


ðŸ’¡ Note:
Each transaction type:
----------------------
Reuses the common algorithm steps from AbstractTransactionTemplate.
Customizes only the unique parts (doTransfer, postTransfer, etc.).

4. Service Layer Integration (unchanged)
	Your service layer remains mostly the same â€” it simply fetches the right strategy and calls transfer(). 
	â€œskeletonâ€ â€” subclasses define the custom â€œfillingâ€.






                 +---------------------------+
                 |  AbstractTransactionTemplate |
                 |---------------------------|
                 | + executeTransfer()       |
                 | + validateAccounts()      |
                 | + doTransfer() [abstract] |
                 | + auditTransaction()      |
                 +-------------^-------------+
                               |
     +--------------------------+---------------------------+
     |                          |                           |
 [NEFTTransaction]      [RTGSTransaction]          [IMPSTransaction]
    | implements TransactionStrategy        (customize doTransfer)
    |
    v
 TransactionStrategyFactory
    |
    v
 AccountService -> chooses strategy -> executes transfer template
    |
    v
 AccountController -> REST /transfer?tx_type=NEFT



POST /api/accounts/transfer?from=1&to=2&amount=5000&tx_type=NEFT

Controller calls AccountService.transfer(...)

Service fetches strategy: TransactionStrategyFactory.getStrategy(TransactionType.NEFT)

Strategy (NEFTTransaction) inherits from AbstractTransactionTemplate

Calls executeTransfer() â†’ runs fixed workflow:

âœ… validateAccounts()

ðŸ§¾ preTransfer()

ðŸ’¸ doTransfer() â†’ NEFT-specific logic

ðŸ“¢ notifyParties()

ðŸ—‚ auditTransaction()

Response â†’ "Transfer successful using NEFT!"









public class AccountService {
   public void transfer(int from, int to, double amount){
   
	}
}

LedgerService.java
-----------------------
public class LedgerService {
    public void record(int from, int to, double amount) {
        System.out.println("Ledger updated: Transfer of " + amount + " from " + from + " to " + to);
    }
}

FraudService.java
-----------------------
public class FraudService {
    public boolean validate(int from, int to, double amount) {
        System.out.println("Validating fraud for " + amount + " transfer...");
        return amount < 100000; // simple rule
    }
}

NotificationService.java
-----------------------
public class NotificationService {
    public void send(String message) {
        System.out.println("SMS Notification Sent: " + message);
    }
}

The Facade Class

FundTransferFacade.java
-----------------------
public class FundTransferFacade {
public void transferFunds(String fromAcc, String toAcc, double amount);
}

public class FundTransferFacadeImpl {

    private final AccountService accountService;
    private final LedgerService ledgerService;
    private final FraudService fraudService;
    private final NotificationService notificationService;

    public FundTransferFacade() {
        this.accountService = new AccountService();
        this.ledgerService = new LedgerService();
        this.fraudService = new FraudService();
        this.notificationService = new NotificationService();
    }

    public void transferFunds(String fromAcc, String toAcc, double amount) {
        System.out.println("---- Initiating Fund Transfer ----");

        if (!fraudService.validate(fromAcc, toAcc, amount)) {
            notificationService.send("Transfer blocked due to suspected fraud!");
            System.out.println(" Fraud detected, transfer aborted.");
            return;
        }

        accountService.debit(fromAcc, amount);
        accountService.credit(toAcc, amount);
        ledgerService.record(fromAcc, toAcc, amount);
        notificationService.send("Transfer of â‚¹" + amount + " from " + fromAcc + " to " + toAcc + " successful!");

        System.out.println(" Transfer completed successfully!");
    }
}




Spring boot bankapp: strategy design pattern:
============================================


public enum TransactionType {
    NEFT, RTGS, IMPS
}

@Data
public class TransactionRequest {
    private int fromAccId;
    private int toAccId;
    private BigDecimal amount;
    private TransactionType txType;
}


public interface TransactionStrategy {
    void transfer(Account from, Account to, BigDecimal amount);
}


@Component("NEFT")
public class NEFTStrategy implements TransactionStrategy {
    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        System.out.println("Processing NEFT transfer...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }
}

@Component("RTGS")
public class RTGSStrategy implements TransactionStrategy {
    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        System.out.println("Processing RTGS transfer with high-value check...");
        if (amount.compareTo(new BigDecimal("200000")) < 0) {
            throw new IllegalArgumentException("RTGS minimum amount should be â‚¹2,00,000");
        }
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }
}

@Component("IMPS")
public class IMPSStrategy implements TransactionStrategy {
    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        System.out.println("Processing IMPS instant transfer...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }
}


@Component
public class TransactionStrategyFactory {

    private final Map<String, TransactionStrategy> strategyMap;

    @Autowired
    public TransactionStrategyFactory(Map<String, TransactionStrategy> strategyMap) {
        this.strategyMap = strategyMap;
    }

    public TransactionStrategy getStrategy(TransactionType type) {
        return strategyMap.get(type.name());
    }
}



@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private TransactionStrategyFactory factory;

    public void executeTransfer(int fromAccId, int toAccId, BigDecimal amount, TransactionType type) {
        Account from = dao.getById(fromAccId);
        Account to = dao.getById(toAccId);
        TransactionStrategy strategy = factory.getStrategy(type);
        strategy.transfer(from, to, amount);
        dao.updateAccount(from);
        dao.updateAccount(to);
    }
}


@RestController
@RequestMapping("/api/transactions")
public class TransactionController {

    @Autowired
    private AccountService service;

    @PostMapping("/transfer")
    public String transferFunds(@RequestBody TransactionRequest request) {
        service.executeTransfer(
                request.getFromAccId(),
                request.getToAccId(),
                request.getAmount(),
                request.getTxType()
        );
        return "Transfer of â‚¹" + request.getAmount() +
               " via " + request.getTxType() + " completed successfully.";
    }
}




You already have:
------------------------------
TransactionStrategy â€” defines algorithm family (which strategy to use, e.g., NEFT, RTGS, etc.)
Each concrete strategy (NEFTStrategy, RTGSStrategy) â€” implements transfer(...).

Now, youâ€™ll add a Template pattern to:
Define a fixed skeleton of a transfer process (pre-check â†’ core transfer â†’ audit â†’ notification).
Let each subtype (strategy) override only the variable steps (like how transfer happens or fee calculation).

This gives you two levels of flexibility:
-------------------------------------------
Strategy â†’ chooses which transaction method to execute (runtime decision).
Template â†’ defines how the method itself is structured internally.



public abstract class AbstractTransactionTemplate {

    // Template method: defines the workflow
    public final void executeTransfer(Account from, Account to, BigDecimal amount) {
        validateAccounts(from, to);
        preTransfer(from, to, amount);
        doTransfer(from, to, amount);     // delegated to subclass
        postTransfer(from, to, amount);
        notifyParties(from, to, amount);
        auditTransaction(from, to, amount);
    }

    // Common steps (can be final or overridable)
    protected void validateAccounts(Account from, Account to) {
        if (from == null || to == null) {
            throw new IllegalArgumentException("Invalid accounts provided");
        }
        if (from.getBalance().compareTo(amountLimit()) < 0) {
            throw new IllegalStateException("Insufficient funds in sender account");
        }
    }

    protected void preTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Starting transaction of amount " + amount);
    }

    protected abstract void doTransfer(Account from, Account to, BigDecimal amount);

    protected void postTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Transaction completed successfully");
    }

    protected void notifyParties(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Sending SMS to both parties");
    }

    protected void auditTransaction(Account from, Account to, BigDecimal amount) {
        System.out.println("[Common] Auditing transaction in log system");
    }

    // hook method â€” subclasses may override
    protected BigDecimal amountLimit() {
        return BigDecimal.ZERO;
    }
}


This class provides theConcrete Transaction Templates
------------------------------------------------------------
Each strategy (e.g., NEFT, RTGS, IMPS) can extend this template and override the variable steps.

package com.busycoder.bank.strategy;

import com.busycoder.bank.model.Account;
import com.busycoder.bank.template.AbstractTransactionTemplate;
import org.springframework.stereotype.Component;
import java.math.BigDecimal;

@Component("NEFT")
public class NEFTTransaction extends AbstractTransactionTemplate implements TransactionStrategy {

    @Override
    protected void doTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[NEFT] Deducting amount slowly via NEFT network...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }

    @Override
    protected BigDecimal amountLimit() {
        return new BigDecimal("10000"); // NEFT has a minimum threshold check (example)
    }

    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        executeTransfer(from, to, amount);
    }
}


Similarly, for RTGS:
-----------------------
@Component("RTGS")
public class RTGSTransaction extends AbstractTransactionTemplate implements TransactionStrategy {

    @Override
    protected void doTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[RTGS] High-value instant transfer...");
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
    }

    @Override
    protected void postTransfer(Account from, Account to, BigDecimal amount) {
        System.out.println("[RTGS] Sending instant confirmation email for RTGS.");
    }

    @Override
    public void transfer(Account from, Account to, BigDecimal amount) {
        executeTransfer(from, to, amount);
    }
}


ðŸ’¡ Note:
Each transaction type:
----------------------
Reuses the common algorithm steps from AbstractTransactionTemplate.
Customizes only the unique parts (doTransfer, postTransfer, etc.).

4. Service Layer Integration (unchanged)
	Your service layer remains mostly the same â€” it simply fetches the right strategy and calls transfer(). 
	â€œskeletonâ€ â€” subclasses define the custom â€œfillingâ€.






                 +---------------------------+
                 |  AbstractTransactionTemplate |
                 |---------------------------|
                 | + executeTransfer()       |
                 | + validateAccounts()      |
                 | + doTransfer() [abstract] |
                 | + auditTransaction()      |
                 +-------------^-------------+
                               |
     +--------------------------+---------------------------+
     |                          |                           |
 [NEFTTransaction]      [RTGSTransaction]          [IMPSTransaction]
    | implements TransactionStrategy        (customize doTransfer)
    |
    v
 TransactionStrategyFactory
    |
    v
 AccountService -> chooses strategy -> executes transfer template
    |
    v
 AccountController -> REST /transfer?tx_type=NEFT



POST /api/accounts/transfer?from=1&to=2&amount=5000&tx_type=NEFT

Controller calls AccountService.transfer(...)

Service fetches strategy: TransactionStrategyFactory.getStrategy(TransactionType.NEFT)

Strategy (NEFTTransaction) inherits from AbstractTransactionTemplate

Calls executeTransfer() â†’ runs fixed workflow:

âœ… validateAccounts()

ðŸ§¾ preTransfer()

ðŸ’¸ doTransfer() â†’ NEFT-specific logic

ðŸ“¢ notifyParties()

ðŸ—‚ auditTransaction()

Response â†’ "Transfer successful using NEFT!"









public class AccountService {
   public void transfer(int from, int to, double amount){
   
	}
}

LedgerService.java
-----------------------
public class LedgerService {
    public void record(int from, int to, double amount) {
        System.out.println("Ledger updated: Transfer of " + amount + " from " + from + " to " + to);
    }
}

FraudService.java
-----------------------
public class FraudService {
    public boolean validate(int from, int to, double amount) {
        System.out.println("Validating fraud for " + amount + " transfer...");
        return amount < 100000; // simple rule
    }
}

NotificationService.java
-----------------------
public class NotificationService {
    public void send(String message) {
        System.out.println("SMS Notification Sent: " + message);
    }
}

The Facade Class

FundTransferFacade.java
-----------------------
public class FundTransferFacade {
public void transferFunds(String fromAcc, String toAcc, double amount);
}

public class FundTransferFacadeImpl {

    private final AccountService accountService;
    private final LedgerService ledgerService;
    private final FraudService fraudService;
    private final NotificationService notificationService;

    public FundTransferFacade() {
        this.accountService = new AccountService();
        this.ledgerService = new LedgerService();
        this.fraudService = new FraudService();
        this.notificationService = new NotificationService();
    }

    public void transferFunds(String fromAcc, String toAcc, double amount) {
        System.out.println("---- Initiating Fund Transfer ----");

        if (!fraudService.validate(fromAcc, toAcc, amount)) {
            notificationService.send("Transfer blocked due to suspected fraud!");
            System.out.println(" Fraud detected, transfer aborted.");
            return;
        }

        accountService.debit(fromAcc, amount);
        accountService.credit(toAcc, amount);
        ledgerService.record(fromAcc, toAcc, amount);
        notificationService.send("Transfer of â‚¹" + amount + " from " + fromAcc + " to " + toAcc + " successful!");

        System.out.println(" Transfer completed successfully!");
    }
}


Property file sample:
-------------------
server.port=8090
server.servlet.context-path=/bankapp

spring.datasource.driver-class-name= com.mysql.jdbc.Driver
spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.hibernate.ddl-auto= update
spring.datasource.url=jdbc:mysql://localhost:3306/busycoder?useSSL=false
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=update

# if u want to disable logging
#logging.level.root=OFF
#logging.level.org.springframework.boot=OFF
#spring.main.banner-mode=OFF


logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR
logging.level.com.productapp: INFO
logging.level.com.productapp.service: INFO

logging.pattern.console= "%d{yyyy-MM-dd } [%thread] %-5level %logger{36} - %msg%n"
#logging pattern for file
logging.pattern.file= "%d{yyyy-MM-dd } [%thread] %-5level %logger{36} - %msg%n"
#i wnat to send logs to a specific file?

spring.jpa.show-sql=true 
spring.banner.location=	
spring.jmx.enabled=true
management.endpoints.web.exposure.include=*
management.endpoints.jmx.exposure.include=*
management.info.env.enabled=true
info.app.encoding=UTF-8
info.app.java.source=21
info.app.java.target=21
info.app.name=productapp
info.app.dev=amit ku

management.endpoint.health.show-details=always
management.endpoint.health.probes.enabled=true
# livenessstate readinessstate
#management.health.livenessstate.enabled=true
#management.health.readinessstate.enabled=true


info.key=default
spring.profiles.active=test

UserInterface.TRANSFER_SUCCESS=transfer done successfully
UserInterface.DEPOSIT_SUCCESS=amount deposit successfully
UserInterface.WITHDRAW_SUCCESS=amount withdraw successfully

Service.ACCOUNT_NOT_EXISTS=Account not exist

Service.FROM_ACCOUNT_NOT_EXISTS=From Account not exist

Service.TO_ACCOUNT_NOT_EXISTS=To Account not exist

Service.NOT_SUFFICIENT_BALANCE=Account dont have sufficient balance




spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=foo
spring.datasource.password=foo
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

spring.h2.console.enabled=true

# Custom H2 Console URL
spring.h2.console.path=/h2

spring.jpa.hibernate.ddl-auto=update
